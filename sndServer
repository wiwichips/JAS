#!/bin/bash

# job pipe
FIFO_S="/tmp/server-${USER}-fifo"
mkfifo $FIFO_S

# server pid
serverPID=$$

# cpu stuff
numCPU=8
idle=()
cpuPID=()

# job queue
jobQueue=()
numJobs=0

# extra status info
numDone=0

# usage - addToQueue "job"
function addToQ {
	jobQueue+=($1)
  numJobs=$((numJobs+1))
}

# usage - pass the array by name for first index, then pop
function popQ {
  newArray=()
  for i in $(seq $((numJobs - 1)))
	do
    newArray+=(${jobQueue[$i]})
	done
  unset jobQueue
  jobQueue=(${newArray[@]})
}

# cpu stuff
function initIdleArray {
	# fill the array with as many 1s as there are CPUS in the computer
	for i in $(seq $numCPU)
	do
		idle+=(1)
	done
}

function sendJob {
  # record pid of processor in processor pid array
  local cpuID=$1
  local job=$2

  ./sndProcessor $cpuID $$ $job &
  cpuPID[$cpuID]=$!
}

function assignJob {
  for i in $(seq $numCPU)
	do
		if [ ${idle[$i]} -eq 1 ]
    then
      sendJob $i $jobQueue
      popQ
      idle[$i]=0
      break
    fi
	done
}

# only called when a job finished via a signal, checks all pids to see if they exist
function updateIdle {
  local v=$1

  if [ "$v" = 'v' ]
  then
    echo "There are $numCPU processors"
    echo "$numDone jobs have been completed"
  fi

  for i in $(seq $numCPU)
	do
    if [ -n "${cpuPID[$i]}" -a -e /proc/${cpuPID[$i]} ]
    then
      if [ "$v" = 'v' ]; then echo "$i: busy"; fi
      idle[$i]=0
    else
      if [ "$v" = 'v' ]; then echo "$i: idle"; fi
      idle[$i]=1
    fi
	done
}

function updateTotal {
  numDone=$((numDone+1))
}

# traps
# trap "updateIdle; numDone=$((numDone+1))" SIGUSR1
trap "updateIdle; updateTotal" SIGUSR1
trap "rm -f $FIFO_S; exit 0" 0 1 2 15

# set all cpus to idle (1)
initIdleArray

while read line < $FIFO_S
do
	if [ "$line" = 'exit' ]
	then
		break
	fi

  if [ "$line" = 'status' ]
	then
    echo "~           $numCPU"
    echo "~"
		updateIdle "v"
  else
    # add it to the job queue
    addToQ $line

    # check if there are free CPUs
    assignJob
	fi
done
