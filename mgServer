#!/bin/bash

#
# set up some globals
#

# pipe names
FIFO_S="/tmp/server-${USER}-fifo"
FIFO_P="/tmp/processor-${USER}-fifo"

# calculate default number of processors
numCPU=$(getconf _NPROCESSORS_ONLN)

# array of cpubusyness
idle=() # 1 repreesents idle, 0 represents busy
jobQueue=()
jobInd=0

#
# functions
#

function addToQ {
	job=$1
	jobQueue+=($job)
}

# this function is called when a CPU is ready to be used
function scheduleJob {
	# pop from the job queue
	job=$jobQueue[jobInd]
	jobInd+=1
	
	# assign the job to the first free CPU
	for i in "${idle[@]}"
	do
		if [ "${idle[3i]}" == "1" ]; then
    	idle[$i]=
		fi
	done
}

function initIdleArray {
	# fill the array with as many 1s as there are CPUS in the computer
	for i in $(seq $numCPU)
	do
		idle+=(1)
	done
}



# process command line options (so that number of processors can be overridden)
PRINT_HELP="NO"
# check for the flags and options passed
for arg in "$@"
do
	case "${arg}" in
	-[h?]*)
		PRINT_HELP="YES"
		;;
	-*)
		echo "Unknown option '${arg}'" >&2
        exit -1
		;;
	*)
		echo "Unknown argument '${arg}'" >&2
        exit -1
		;;
	esac
done


# if help was requested, print it to stderr and exit
if [ X"$PRINT_HELP" = X"YES" ]
then
    echo "$0 <options>" >&2
    echo "Option:" >&2
    echo "-h    : help - this is it" >&2
    echo "-n<N> : set the number of processing units to <N>" >&2
    exit -1
fi

# initialize the array of idle cpu data
initIdleArray

# make the server fifo
mkfifo $FIFO_S
trap "rm -f $FIFO_S; exit 0" 0 1 2 15

# read from the server fifo
while read line < $FIFO_S
do
	if [ "$line" = 'exit' ]
	then
		break
	fi

	# schedule the job
	addToQ "$line"
done
